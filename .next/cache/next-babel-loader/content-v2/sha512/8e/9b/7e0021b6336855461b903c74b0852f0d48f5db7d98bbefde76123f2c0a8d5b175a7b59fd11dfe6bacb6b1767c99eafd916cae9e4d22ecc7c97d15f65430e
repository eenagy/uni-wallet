{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core';\nimport { useEffect, useState } from 'react';\nimport { isMobile } from 'react-device-detect';\nimport { injected } from '../connectors';\nimport { NetworkContextName } from '../constants';\nexport function useActiveWeb3React() {\n  _s();\n\n  var context = useWeb3ReactCore();\n  var contextNetwork = useWeb3ReactCore(NetworkContextName);\n  return context.active ? context : contextNetwork;\n}\n\n_s(useActiveWeb3React, \"WFPFKE/y5H/nwl1Zbqr6M/3MM8c=\", false, function () {\n  return [useWeb3ReactCore, useWeb3ReactCore];\n});\n\nexport function useEagerConnect() {\n  _s2();\n\n  var _useWeb3ReactCore = useWeb3ReactCore(),\n      activate = _useWeb3ReactCore.activate,\n      active = _useWeb3ReactCore.active; // specifically using useWeb3ReactCore because of what this hook does\n\n\n  var _useState = useState(false),\n      tried = _useState[0],\n      setTried = _useState[1];\n\n  useEffect(function () {\n    injected.isAuthorized().then(function (isAuthorized) {\n      if (isAuthorized) {\n        activate(injected, undefined, true)[\"catch\"](function () {\n          setTried(true);\n        });\n      } else {\n        if (isMobile && window.ethereum) {\n          activate(injected, undefined, true)[\"catch\"](function () {\n            setTried(true);\n          });\n        } else {\n          setTried(true);\n        }\n      }\n    });\n  }, [activate]); // intentionally only running on mount (make sure it's only mounted once :))\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(function () {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n  return tried;\n}\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\n\n_s2(useEagerConnect, \"Bhmb87TsYv+f2WbPhdXmj7sGsFM=\", false, function () {\n  return [useWeb3ReactCore];\n});\n\nexport function useInactiveListener() {\n  _s3();\n\n  var suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  var _useWeb3ReactCore2 = useWeb3ReactCore(),\n      active = _useWeb3ReactCore2.active,\n      error = _useWeb3ReactCore2.error,\n      activate = _useWeb3ReactCore2.activate; // specifically using useWeb3React because of what this hook does\n\n\n  useEffect(function () {\n    var _window = window,\n        ethereum = _window.ethereum;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      var handleChainChanged = function handleChainChanged() {\n        // eat errors\n        activate(injected, undefined, true)[\"catch\"](function (error) {\n          console.error('Failed to activate after chain changed', error);\n        });\n      };\n\n      var handleAccountsChanged = function handleAccountsChanged(accounts) {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true)[\"catch\"](function (error) {\n            console.error('Failed to activate after accounts changed', error);\n          });\n        }\n      };\n\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n      return function () {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n\n    return undefined;\n  }, [active, error, suppress, activate]);\n}\n\n_s3(useInactiveListener, \"jN4RZ0OvqgaQw3T0lu1/qJ1z0K8=\", false, function () {\n  return [useWeb3ReactCore];\n});","map":{"version":3,"sources":["/Users/admin/workspace/smart_contracts/uni-wallet/src/hooks/index.ts"],"names":["useWeb3React","useWeb3ReactCore","useEffect","useState","isMobile","injected","NetworkContextName","useActiveWeb3React","context","contextNetwork","active","useEagerConnect","activate","tried","setTried","isAuthorized","then","undefined","window","ethereum","useInactiveListener","suppress","error","on","handleChainChanged","console","handleAccountsChanged","accounts","length","removeListener"],"mappings":"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","sourcesContent":["import { Web3Provider } from '@ethersproject/providers'\nimport { ChainId } from '@uniswap/sdk'\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core'\nimport { Web3ReactContextInterface } from '@web3-react/core/dist/types'\nimport { useEffect, useState } from 'react'\nimport { isMobile } from 'react-device-detect'\nimport { injected } from '../connectors'\nimport { NetworkContextName } from '../constants'\n\nexport function useActiveWeb3React(): Web3ReactContextInterface<Web3Provider> & { chainId?: ChainId } {\n  const context = useWeb3ReactCore<Web3Provider>()\n  const contextNetwork = useWeb3ReactCore<Web3Provider>(NetworkContextName)\n  return context.active ? context : contextNetwork\n}\n\nexport function useEagerConnect() {\n  const { activate, active } = useWeb3ReactCore() // specifically using useWeb3ReactCore because of what this hook does\n  const [tried, setTried] = useState(false)\n\n  useEffect(() => {\n    injected.isAuthorized().then((isAuthorized: boolean) => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true)\n        })\n      } else {\n        if (isMobile && window.ethereum) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true)\n          })\n        } else {\n          setTried(true)\n        }\n      }\n    })\n  }, [activate]) // intentionally only running on mount (make sure it's only mounted once :))\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect(() => {\n    if (active) {\n      setTried(true)\n    }\n  }, [active])\n\n  return tried\n}\n\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\nexport function useInactiveListener(suppress = false) {\n  const { active, error, activate } = useWeb3ReactCore() // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const { ethereum } = window\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(error => {\n          console.error('Failed to activate after chain changed', error)\n        })\n      }\n\n      const handleAccountsChanged = (accounts: string[]) => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(error => {\n            console.error('Failed to activate after accounts changed', error)\n          })\n        }\n      }\n\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n        }\n      }\n    }\n    return undefined\n  }, [active, error, suppress, activate])\n}\n"]},"metadata":{},"sourceType":"module"}